<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0045)http://www-scf.usc.edu/~flv/ipbook/chap07.htm -->
<HTML><HEAD><TITLE>第7章 边沿检测与提取，轮廓跟踪</TITLE>
<META http-equiv=Content-Type content="text/html; charset=GB2312"><LINK 
href="./chap07.files/editdata.mso" rel=Edit-Time-Data><LINK 
href="./chap07.files/oledata.mso" rel=OLE-Object-Data>
<STYLE>.Normal {
	TEXT-JUSTIFY: inter-ideograph; FONT-SIZE: 10.5pt; TEXT-INDENT: 0pt; LINE-HEIGHT: normal; FONT-FAMILY: "Times New Roman"; TEXT-ALIGN: justify
}
.a {
	FONT-SIZE: 12pt; TEXT-INDENT: 0pt; LINE-HEIGHT: 20pt; FONT-FAMILY: "Times New Roman"; TEXT-ALIGN: center
}
</STYLE>

<META content="MSHTML 6.00.2800.1400" name=GENERATOR></HEAD>
<BODY class=Normal lang=ZH-CN vLink=purple link=blue bgColor=#ffffff>
<DIV style="LAYOUT-GRID:  15.6pt none">
<H1><A name=_Toc486331897></A><A name=_Toc486332897></A><A 
name=_Toc486339006></A><A name=_Toc454810871></A><A 
name=_Toc454856645><SPAN><SPAN>第<SPAN 
lang=EN-US>7</SPAN></SPAN></SPAN></A><SPAN><SPAN><SPAN 
style="FONT-FAMILY: 黑体">章</SPAN> </SPAN></SPAN><SPAN><SPAN><SPAN 
style="FONT-FAMILY: 黑体">边沿检测与提取，轮廓跟踪</SPAN></SPAN></SPAN></H1>
<P style="LINE-HEIGHT: 18pt"><SPAN 
style="FONT-FAMILY: 宋体">我们在第三章介绍平滑与锐化时引入了模板操作，今天还要用到它。</SPAN></P>
<H2><SPAN lang=EN-US>7.1</SPAN> <SPAN lang=EN-US></SPAN><A 
name=_Toc486331898></A><A name=_Toc486332898></A><A name=_Toc486339007></A><A 
name=_Toc454810872></A><A 
name=_Toc454856646><SPAN><SPAN>边沿检测</SPAN></SPAN></A></H2>
<P style="LINE-HEIGHT: 18pt"><SPAN style="FONT-FAMILY: 宋体">我们给出一个模板</SPAN><SPAN 
lang=EN-US><SUB> <IMG height=23 src="第7章 边沿检测与提取，轮廓跟踪.files/image002.gif" 
width=76 v:shapes="_x0000_i1025"> </SUB></SPAN><SPAN 
style="FONT-FAMILY: 宋体">和一幅图象</SPAN><SPAN lang=EN-US><SUB> <IMG height=96 
src="第7章 边沿检测与提取，轮廓跟踪.files/image004.gif" width=228 v:shapes="_x0000_i1026"> 
</SUB></SPAN><SPAN 
style="FONT-FAMILY: 宋体">。不难发现原图中左边暗，右边亮，中间存在着一条明显的边界。进行模板操作后的结果如下：</SPAN><SPAN 
lang=EN-US><SUB> <IMG height=96 src="第7章 边沿检测与提取，轮廓跟踪.files/image006.gif" 
width=229 v:shapes="_x0000_i1027"> </SUB></SPAN><SPAN 
style="FONT-FAMILY: 宋体">。</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN style="FONT-FAMILY: 宋体">可以看出，第</SPAN><SPAN 
lang=EN-US>3</SPAN><SPAN style="FONT-FAMILY: 宋体">、</SPAN><SPAN 
lang=EN-US>4</SPAN><SPAN 
style="FONT-FAMILY: 宋体">列比其他列的灰度值高很多，人眼观察时，就能发现一条很明显的亮边，其它区域都很暗，这样就起到了边沿检测的作用。</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
style="FONT-FAMILY: 宋体">为什么会这样呢？仔细看看那个模板就明白了，它的意思是将右邻点的灰度值减左邻点的灰度值作为该点的灰度值。在灰度相近的区域内，这么做的结果使得该点的灰度值接近于</SPAN><SPAN 
lang=EN-US>0</SPAN><SPAN 
style="FONT-FAMILY: 宋体">；而在边界附近，灰度值有明显的跳变，这么做的结果使得该点的灰度值很大，这样就出现了上面的结果。</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
style="FONT-FAMILY: 宋体">这种模板就是一种边沿检测器，它在数学上的涵义是一种基于梯度的滤波器，又称边沿算子，你没有必要知道梯度的确切涵义，只要有这个概念就可以了。梯度是有方向的，和边沿的方向总是正交</SPAN><SPAN 
lang=EN-US>(</SPAN><SPAN style="FONT-FAMILY: 宋体">垂直</SPAN><SPAN 
lang=EN-US>)</SPAN><SPAN 
style="FONT-FAMILY: 宋体">的，例如，对于上面那幅图象的转置图象，边是水平方向的，我们可以用梯度是垂直方向的模板</SPAN><SPAN 
lang=EN-US><SUB> <IMG height=75 src="第7章 边沿检测与提取，轮廓跟踪.files/image008.gif" 
width=36 v:shapes="_x0000_i1035"> </SUB></SPAN><SPAN 
style="FONT-FAMILY: 宋体">检测它的边沿。</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN style="FONT-FAMILY: 宋体">例如，一个梯度为</SPAN><SPAN 
lang=EN-US>45</SPAN><SPAN style="FONT-FAMILY: 宋体">度方向模板</SPAN><SPAN 
lang=EN-US><SUB> <IMG height=75 src="第7章 边沿检测与提取，轮廓跟踪.files/image010.gif" 
width=91 v:shapes="_x0000_i1036"> </SUB></SPAN><SPAN 
style="FONT-FAMILY: 宋体">，可以检测出</SPAN><SPAN lang=EN-US>135</SPAN><SPAN 
style="FONT-FAMILY: 宋体">度方向的边沿。</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><B><SPAN lang=EN-US>1.<SPAN 
style="FONT: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN></SPAN></B><B><SPAN lang=EN-US>Sobel</SPAN></B><B><SPAN 
style="FONT-FAMILY: 宋体">算子</SPAN><SPAN lang=EN-US></SPAN></B></P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
style="FONT-FAMILY: 宋体">在边沿检测中，常用的一种模板是</SPAN><SPAN lang=EN-US>Sobel 
</SPAN><SPAN style="FONT-FAMILY: 宋体">算子。</SPAN><SPAN lang=EN-US>Sobel 
</SPAN><SPAN style="FONT-FAMILY: 宋体">算子有两个，一个是检测水平边沿的</SPAN><SPAN 
lang=EN-US><SUB> <IMG height=75 src="第7章 边沿检测与提取，轮廓跟踪.files/image012.gif" 
width=103 v:shapes="_x0000_i1037"> </SUB></SPAN><SPAN 
style="FONT-FAMILY: 宋体">；另一个是检测垂直平边沿的</SPAN><SPAN lang=EN-US><SUB> <IMG 
height=75 src="第7章 边沿检测与提取，轮廓跟踪.files/image014.gif" width=88 
v:shapes="_x0000_i1038"> </SUB></SPAN><SPAN 
style="FONT-FAMILY: 宋体">。与</SPAN><SPAN lang=EN-US><SUB> <IMG height=75 
src="第7章 边沿检测与提取，轮廓跟踪.files/image016.gif" width=100 v:shapes="_x0000_i1039"> 
</SUB></SPAN><SPAN style="FONT-FAMILY: 宋体">和</SPAN><SPAN lang=EN-US><SUB> <IMG 
height=75 src="第7章 边沿检测与提取，轮廓跟踪.files/image018.gif" width=81 
v:shapes="_x0000_i1040"> </SUB></SPAN><SPAN 
style="FONT-FAMILY: 宋体">相比，</SPAN><SPAN lang=EN-US>Sobel</SPAN><SPAN 
style="FONT-FAMILY: 宋体">算子对于象素的位置的影响做了加权，因此效果更好。</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>Sobel</SPAN><SPAN 
style="FONT-FAMILY: 宋体">算子另一种形式是各向同性</SPAN><SPAN lang=EN-US>Sobel(Isotropic 
Sobel)</SPAN><SPAN style="FONT-FAMILY: 宋体">算子，也有两个，一个是检测水平边沿的</SPAN><SPAN 
lang=EN-US><SUB> <IMG height=80 src="第7章 边沿检测与提取，轮廓跟踪.files/image020.gif" 
width=115 v:shapes="_x0000_i1041"> </SUB></SPAN><SPAN 
style="FONT-FAMILY: 宋体">，另一个是检测垂直平边沿的</SPAN><SPAN lang=EN-US><SUB> <IMG 
height=75 src="第7章 边沿检测与提取，轮廓跟踪.files/image022.gif" width=112 
v:shapes="_x0000_i1042"> </SUB></SPAN><SPAN 
style="FONT-FAMILY: 宋体">。各向同性</SPAN><SPAN lang=EN-US>Sobel</SPAN><SPAN 
style="FONT-FAMILY: 宋体">算子和普通</SPAN><SPAN lang=EN-US>Sobel</SPAN><SPAN 
style="FONT-FAMILY: 宋体">算子相比，它的位置加权系数更为准确，在检测不同方向的边沿时梯度的幅度一致。</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN style="FONT-FAMILY: 宋体">下面的几幅图中，图</SPAN><SPAN 
lang=EN-US>7.1</SPAN><SPAN style="FONT-FAMILY: 宋体">为原图；图</SPAN><SPAN 
lang=EN-US>7.2</SPAN><SPAN style="FONT-FAMILY: 宋体">为普通</SPAN><SPAN 
lang=EN-US>Sobel</SPAN><SPAN style="FONT-FAMILY: 宋体">算子处理后的结果图；图</SPAN><SPAN 
lang=EN-US>7.3</SPAN><SPAN style="FONT-FAMILY: 宋体">为各向同性</SPAN><SPAN 
lang=EN-US>Sobel</SPAN><SPAN style="FONT-FAMILY: 宋体">算子处理后的结果图。可以看出</SPAN><SPAN 
lang=EN-US>Sobel</SPAN><SPAN 
style="FONT-FAMILY: 宋体">算子确实把图象中的边沿提取了出来。</SPAN></P>
<P style="LINE-HEIGHT: 18pt; TEXT-ALIGN: center" align=center><SPAN 
lang=EN-US><IMG height=202 src="第7章 边沿检测与提取，轮廓跟踪.files/image024.jpg" width=319 
v:shapes="_x0000_i1043"> </SPAN></P>
<P style="LINE-HEIGHT: 18pt; TEXT-ALIGN: center" align=center><B><SPAN 
style="FONT-FAMILY: 宋体">图</SPAN>7.1&nbsp;&nbsp;&nbsp;&nbsp; </B><B><SPAN 
style="FONT-FAMILY: 宋体">原图</SPAN><SPAN lang=EN-US></SPAN></B></P>
<P style="LINE-HEIGHT: 18pt; TEXT-ALIGN: center" align=center><SPAN 
lang=EN-US><IMG height=201 src="第7章 边沿检测与提取，轮廓跟踪.files/image026.jpg" width=319 
v:shapes="_x0000_i1044"> </SPAN></P>
<P style="LINE-HEIGHT: 18pt; TEXT-ALIGN: center" align=center><B><SPAN 
style="FONT-FAMILY: 宋体">图</SPAN>7.2&nbsp;&nbsp;&nbsp;&nbsp; </B><B><SPAN 
style="FONT-FAMILY: 宋体">普通</SPAN><SPAN lang=EN-US>Sobel</SPAN></B><B><SPAN 
style="FONT-FAMILY: 宋体">算子处理后的结果图</SPAN><SPAN lang=EN-US></SPAN></B></P>
<P style="LINE-HEIGHT: 18pt; TEXT-ALIGN: center" align=center><B><SPAN 
lang=EN-US><IMG height=200 src="第7章 边沿检测与提取，轮廓跟踪.files/image028.jpg" width=316 
v:shapes="_x0000_i1045"> </SPAN></B></P>
<P style="LINE-HEIGHT: 18pt; TEXT-ALIGN: center" align=center><B><SPAN 
style="FONT-FAMILY: 宋体">图</SPAN>7.3&nbsp;&nbsp;&nbsp;&nbsp; </B><B><SPAN 
style="FONT-FAMILY: 宋体">各向同性</SPAN><SPAN lang=EN-US>Sobel</SPAN></B><B><SPAN 
style="FONT-FAMILY: 宋体">算子处理后的结果图</SPAN><SPAN lang=EN-US></SPAN></B></P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
style="FONT-FAMILY: 宋体">在程序中仍然要用到第</SPAN><SPAN lang=EN-US>3</SPAN><SPAN 
style="FONT-FAMILY: 宋体">章介绍的通用</SPAN><SPAN lang=EN-US>3</SPAN><SPAN 
style="FONT-FAMILY: 宋体">×</SPAN><SPAN lang=EN-US>3</SPAN><SPAN 
style="FONT-FAMILY: 宋体">模板操作函数</SPAN><SPAN 
lang=EN-US>TemplateOperation</SPAN><SPAN 
style="FONT-FAMILY: 宋体">，所做的操作只是增加几个常量标识及其对应的模板数组，这里就不再给出了。</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><B><SPAN lang=EN-US>2.<SPAN 
style="FONT: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN></SPAN></B><B><SPAN style="FONT-FAMILY: 宋体">高斯拉普拉斯算子</SPAN><SPAN 
lang=EN-US></SPAN></B></P>
<P style="LINE-HEIGHT: 18pt"><SPAN style="FONT-FAMILY: 宋体">由于噪声点</SPAN><SPAN 
lang=EN-US>(</SPAN><SPAN style="FONT-FAMILY: 宋体">灰度与周围点相差很大的点</SPAN><SPAN 
lang=EN-US>)</SPAN><SPAN 
style="FONT-FAMILY: 宋体">对边沿检测有一定的影响，所以效果更好的边沿检测器是高斯拉普拉斯</SPAN><SPAN 
lang=EN-US>(LOG)</SPAN><SPAN style="FONT-FAMILY: 宋体">算子。它把我们在第</SPAN><SPAN 
lang=EN-US>3</SPAN><SPAN 
style="FONT-FAMILY: 宋体">章中介绍的高斯平滑滤波器和拉普拉斯锐化滤波器结合了起来，先平滑掉噪声，再进行边沿检测，所以效果会更好。</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN style="FONT-FAMILY: 宋体">常用的</SPAN><SPAN 
lang=EN-US>LOG</SPAN><SPAN style="FONT-FAMILY: 宋体">算子是</SPAN><SPAN 
lang=EN-US>5</SPAN><SPAN style="FONT-FAMILY: 宋体">×</SPAN><SPAN 
lang=EN-US>5</SPAN><SPAN style="FONT-FAMILY: 宋体">的模板，如下所示</SPAN><SPAN 
lang=EN-US><SUB> <IMG height=120 src="第7章 边沿检测与提取，轮廓跟踪.files/image030.gif" 
width=187 v:shapes="_x0000_i1046"> </SUB></SPAN><SPAN 
style="FONT-FAMILY: 宋体">。到中心点的距离与位置加权系数的关系用曲线表示为图</SPAN><SPAN 
lang=EN-US>7.4</SPAN><SPAN style="FONT-FAMILY: 宋体">。是不是很象一顶墨西哥草帽？所以，</SPAN><SPAN 
lang=EN-US>LOG</SPAN><SPAN style="FONT-FAMILY: 宋体">又叫墨西哥草帽滤波器。</SPAN></P>
<P class=a style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US><IMG height=148 
src="第7章 边沿检测与提取，轮廓跟踪.files/image032.jpg" width=268 v:shapes="_x0000_i1047"> 
</SPAN></P>
<P style="LINE-HEIGHT: 18pt; TEXT-ALIGN: center" align=center><B><SPAN 
style="FONT-FAMILY: 宋体">图</SPAN>7.4&nbsp;&nbsp;&nbsp;&nbsp; LOG</B><B><SPAN 
style="FONT-FAMILY: 宋体">到中心点的距离与位置加权系数的关系曲线</SPAN><SPAN 
lang=EN-US></SPAN></B></P>
<P style="LINE-HEIGHT: 18pt"><SPAN style="FONT-FAMILY: 宋体">图</SPAN><SPAN 
lang=EN-US>7.5</SPAN><SPAN style="FONT-FAMILY: 宋体">为图</SPAN><SPAN 
lang=EN-US>7.1</SPAN><SPAN style="FONT-FAMILY: 宋体">用</SPAN><SPAN 
lang=EN-US>LOG</SPAN><SPAN style="FONT-FAMILY: 宋体">滤波器处理后的结果。</SPAN></P>
<P class=a style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US><IMG height=192 
src="第7章 边沿检测与提取，轮廓跟踪.files/image034.jpg" width=303 v:shapes="_x0000_i1048"> 
</SPAN></P>
<P style="LINE-HEIGHT: 18pt; TEXT-ALIGN: center" align=center><B><SPAN 
style="FONT-FAMILY: 宋体">图</SPAN>7.5&nbsp;&nbsp;&nbsp;&nbsp; </B><B><SPAN 
style="FONT-FAMILY: 宋体">图</SPAN><SPAN lang=EN-US>7.1</SPAN></B><B><SPAN 
style="FONT-FAMILY: 宋体">用</SPAN><SPAN lang=EN-US>LOG</SPAN></B><B><SPAN 
style="FONT-FAMILY: 宋体">滤波器处理后的结果图</SPAN><SPAN lang=EN-US></SPAN></B></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>LOG</SPAN><SPAN 
style="FONT-FAMILY: 宋体">的算法和普通模板操作的算法没什么不同，只不过把</SPAN><SPAN 
lang=EN-US>3</SPAN><SPAN style="FONT-FAMILY: 宋体">×</SPAN><SPAN 
lang=EN-US>3</SPAN><SPAN style="FONT-FAMILY: 宋体">改成了</SPAN><SPAN 
lang=EN-US>5</SPAN><SPAN style="FONT-FAMILY: 宋体">×</SPAN><SPAN 
lang=EN-US>5</SPAN><SPAN style="FONT-FAMILY: 宋体">，这里就不再给出了。读者可以参照第</SPAN><SPAN 
lang=EN-US>3</SPAN><SPAN style="FONT-FAMILY: 宋体">章的源程序自己来完成。</SPAN></P>
<H2><SPAN lang=EN-US>7.2</SPAN> <A name=_Toc486331899></A><A 
name=_Toc486332899></A><A name=_Toc486339008></A><A name=_Toc454810873></A><A 
name=_Toc454856647><SPAN><SPAN>Hough</SPAN></SPAN></A><SPAN><SPAN><SPAN 
style="FONT-FAMILY: 黑体">变换</SPAN></SPAN></SPAN></H2>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>Hough</SPAN><SPAN 
style="FONT-FAMILY: 宋体">变换用来在图象中查找直线。它的原理很简单：假设有一条与原点距离为</SPAN><SPAN 
lang=EN-US>s</SPAN><SPAN style="FONT-FAMILY: 宋体">，方向角为θ的一条直线，如图</SPAN><SPAN 
lang=EN-US>7.6</SPAN><SPAN style="FONT-FAMILY: 宋体">所示。</SPAN></P>
<P style="LINE-HEIGHT: 18pt; TEXT-ALIGN: center" align=center><SPAN 
lang=EN-US><IMG height=178 src="第7章 边沿检测与提取，轮廓跟踪.files/image036.jpg" width=232 
v:shapes="_x0000_i1049"> </SPAN></P>
<P style="LINE-HEIGHT: 18pt; TEXT-ALIGN: center" align=center><B><SPAN 
style="FONT-FAMILY: 宋体">图</SPAN>7.6&nbsp;&nbsp;&nbsp; </B><B><SPAN 
style="FONT-FAMILY: 宋体">一条与原点距离为</SPAN><SPAN lang=EN-US>s</SPAN></B><B><SPAN 
style="FONT-FAMILY: 宋体">，方向角为θ的一条直线</SPAN><SPAN lang=EN-US></SPAN></B></P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
style="FONT-FAMILY: 宋体">直线上的每一点都满足方程</SPAN></P>
<P style="LINE-HEIGHT: 18pt; TEXT-ALIGN: center" align=center><SPAN 
lang=EN-US><SUB><IMG height=21 src="第7章 边沿检测与提取，轮廓跟踪.files/image038.gif" 
width=128 v:shapes="_x0000_i1050"> </SUB></SPAN></P>
<P style="LINE-HEIGHT: 18pt; TEXT-ALIGN: right" align=right><SPAN 
lang=EN-US>(7.1)</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
style="FONT-FAMILY: 宋体">利用这个事实，我们可以找出某条直线来。下面将给出一段程序，用来找出图象中最长的直线</SPAN><SPAN 
lang=EN-US>(</SPAN><SPAN style="FONT-FAMILY: 宋体">见图</SPAN><SPAN 
lang=EN-US>7.7)</SPAN><SPAN 
style="FONT-FAMILY: 宋体">。找到直线的两个端点，在它们之间连一条红色的直线。为了看清效果，将结果描成粗线，如图</SPAN><SPAN 
lang=EN-US>7.8</SPAN><SPAN style="FONT-FAMILY: 宋体">所示。</SPAN></P>
<TABLE cellSpacing=0 cellPadding=0 border=0>
  <TBODY>
  <TR>
    <TD class=Normal vAlign=top width=276>
      <P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US><IMG height=193 
      src="第7章 边沿检测与提取，轮廓跟踪.files/image040.gif" width=239 
      v:shapes="_x0000_i1051"> </SPAN></P>
      <P style="LINE-HEIGHT: 18pt; TEXT-ALIGN: center" align=center><B><SPAN 
      style="FONT-FAMILY: 宋体">图</SPAN><SPAN lang=EN-US>7.7 </SPAN></B><B><SPAN 
      style="FONT-FAMILY: 宋体">原图</SPAN><SPAN lang=EN-US></SPAN></B></P></TD>
    <TD class=Normal vAlign=top width=276>
      <P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US><IMG height=193 
      src="第7章 边沿检测与提取，轮廓跟踪.files/image042.jpg" width=243 
      v:shapes="_x0000_i1052"> </SPAN></P>
      <P style="LINE-HEIGHT: 18pt; TEXT-ALIGN: center" align=center><B><SPAN 
      style="FONT-FAMILY: 宋体">图</SPAN><SPAN lang=EN-US>7.8 
      Hough</SPAN></B><B><SPAN style="FONT-FAMILY: 宋体">变换的结果</SPAN><SPAN 
      lang=EN-US></SPAN></B></P></TD></TR></TBODY></TABLE>
<P style="LINE-HEIGHT: 18pt"><SPAN 
style="FONT-FAMILY: 宋体">可以看出，找到的确实是最长的直线。方法是，开一个二维数组做为计数器，第一维是角度，第二维是距离。先计算可能出现的最大距离为</SPAN><SPAN 
lang=EN-US><SUB> <IMG height=29 src="第7章 边沿检测与提取，轮廓跟踪.files/image044.gif" 
width=125 v:shapes="_x0000_i1053"> </SUB></SPAN><SPAN 
style="FONT-FAMILY: 宋体">，用来确定数组第二维的大小。对于每一个黑色点，角度的变化范围从</SPAN><SPAN 
lang=EN-US>0<SUP>0</SUP></SPAN><SPAN style="FONT-FAMILY: 宋体">到</SPAN><SPAN 
lang=EN-US>178<SUP>0</SUP>(</SPAN><SPAN 
style="FONT-FAMILY: 宋体">为了减少存储空间和计算时间，角度每次增加</SPAN><SPAN 
lang=EN-US>2<SUP>0</SUP></SPAN><SPAN style="FONT-FAMILY: 宋体">而不是</SPAN><SPAN 
lang=EN-US>1<SUP>0</SUP>)</SPAN><SPAN style="FONT-FAMILY: 宋体">，按方程</SPAN><SPAN 
lang=EN-US>(7.1)</SPAN><SPAN style="FONT-FAMILY: 宋体">求出对应的距离</SPAN><SPAN 
lang=EN-US>s</SPAN><SPAN style="FONT-FAMILY: 宋体">来，相应的数组元素</SPAN><SPAN 
lang=EN-US>[s][<SUB> <IMG height=19 src="第7章 边沿检测与提取，轮廓跟踪.files/image046.gif" 
width=13 v:shapes="_x0000_i1054"> </SUB>]</SPAN><SPAN 
style="FONT-FAMILY: 宋体">加</SPAN><SPAN lang=EN-US>1</SPAN><SPAN 
style="FONT-FAMILY: 宋体">。同时开一个数组</SPAN><SPAN lang=EN-US>Line</SPAN><SPAN 
style="FONT-FAMILY: 宋体">，计算每条直线的上下两个端点。所有的象素都算完后，找到数组元素中最大的，就是最长的那条直线。直线的端点可以在</SPAN><SPAN 
lang=EN-US>Line</SPAN><SPAN 
style="FONT-FAMILY: 宋体">中找到。要注意的是，我们处理的虽然是二值图，但实际上是</SPAN><SPAN 
lang=EN-US>256</SPAN><SPAN style="FONT-FAMILY: 宋体">级灰度图，不过只用到了</SPAN><SPAN 
lang=EN-US>0</SPAN><SPAN style="FONT-FAMILY: 宋体">和</SPAN><SPAN 
lang=EN-US>255</SPAN><SPAN style="FONT-FAMILY: 宋体">两种颜色。</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>BOOL Hough(HWND hWnd)</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>{</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体">定义一个自己的直线结构</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp; </SPAN>typedef struct{</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp; 
</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;int topx; //<SPAN style="FONT-FAMILY: 宋体">最高点的</SPAN><SPAN 
lang=EN-US>x</SPAN><SPAN style="FONT-FAMILY: 宋体">坐标</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp; 
</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;int topy; //<SPAN style="FONT-FAMILY: 宋体">最高点的</SPAN><SPAN 
lang=EN-US>y</SPAN><SPAN style="FONT-FAMILY: 宋体">坐标</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp; 
</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;int botx; //<SPAN style="FONT-FAMILY: 宋体">最低点的</SPAN><SPAN 
lang=EN-US>x</SPAN><SPAN style="FONT-FAMILY: 宋体">坐标</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp; 
</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;int boty; //<SPAN style="FONT-FAMILY: 宋体">最低点的</SPAN><SPAN 
lang=EN-US>y</SPAN><SPAN style="FONT-FAMILY: 宋体">坐标</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp; 
</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;}MYLINE;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>DWORD 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
OffBits,BufSize;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp; </SPAN>&nbsp; 
LPBITMAPINFOHEADER&nbsp;&nbsp;&nbsp; lpImgData;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>LPSTR&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
lpPtr;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>HDC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
hDc;</P>
<P style="LINE-HEIGHT: 18pt">LONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
x,y;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
i,maxd;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dist,Alpha;</P>
<P 
style="LINE-HEIGHT: 18pt">HGLOBAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hDistAlpha,hMyLine;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp; </SPAN>&nbsp; 
Int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp; *lpDistAlpha;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>MYLINE 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
*lpMyLine,*TempLine,MaxdLine;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp; </SPAN>&nbsp; static 
LOGPEN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
rlp={PS_SOLID,1,1,RGB(255,0,0)};</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp; </SPAN>&nbsp; HPEN 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
rhp;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体">我们处理的实际上是</SPAN><SPAN lang=EN-US>256</SPAN><SPAN 
style="FONT-FAMILY: 宋体">级灰度图，不过只用到了</SPAN><SPAN lang=EN-US>0</SPAN><SPAN 
style="FONT-FAMILY: 宋体">和</SPAN><SPAN lang=EN-US>255</SPAN><SPAN 
style="FONT-FAMILY: 宋体">两种颜色。</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>if( NumColors!=256){ </SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>MessageBox(hWnd,"Must be a mono bitmap with grayscale palette!",</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>"Error 
Message",MB_OK|MB_ICONEXCLAMATION);</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>return FALSE;</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>}</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体">计算最大距离</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Dist=(int)(sqrt((double)bi.biWidth*bi.biWidth+</P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
lang=EN-US>(double)bi.biHeight*bi.biHeight)+0.5);</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Alpha=180 /2 ;&nbsp; //0 <SPAN style="FONT-FAMILY: 宋体">到</SPAN><SPAN 
lang=EN-US> to 178 </SPAN><SPAN style="FONT-FAMILY: 宋体">度，步长为</SPAN><SPAN 
lang=EN-US>2</SPAN><SPAN style="FONT-FAMILY: 宋体">度</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">为距离角度数组分配内存</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
lang=EN-US>if((hDistAlpha=GlobalAlloc(GHND,(DWORD)Dist*Alpha*</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>sizeof(int)))==NULL){</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>MessageBox(hWnd,"Error alloc 
memory!","Error Message",</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
lang=EN-US>MB_OK|MB_ICONEXCLAMATION);</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>return FALSE;</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp; </SPAN>}</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">为记录直线端点的数组分配内存</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp; </SPAN>&nbsp;&nbsp;&nbsp; 
if((hMyLine=GlobalAlloc(GHND,(DWORD)Dist*Alpha*</P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
lang=EN-US>sizeof(MYLINE)))==NULL){</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp; 
</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
GlobalFree(hDistAlpha);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp; 
</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp; FALSE;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>OffBits=bf.bfOffBits-sizeof(BITMAPFILEHEADER);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>//BufSize</SPAN><SPAN 
style="FONT-FAMILY: 宋体">为缓冲区大小</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>BufSize=OffBits+bi.biHeight*LineBytes;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp; </SPAN>&nbsp; 
lpImgData=(LPBITMAPINFOHEADER)GlobalLock(hImgData);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp; </SPAN>&nbsp; lpDistAlpha=(int 
*)GlobalLock(hDistAlpha);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>lpMyLine=(MYLINE *)GlobalLock(hMyLine);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>for 
(i=0;i&lt;(long)Dist*Alpha;i++){</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>TempLine=(MYLINE*)(lpMyLine+i);</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>(*TempLine).boty=32767; //<SPAN 
style="FONT-FAMILY: 宋体">初始化最低点的</SPAN><SPAN lang=EN-US>y</SPAN><SPAN 
style="FONT-FAMILY: 宋体">坐标为一个很大的值</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>for (y=0;y&lt;bi.biHeight;y++){</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//lpPtr<SPAN style="FONT-FAMILY: 宋体">指向位图数据</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>lpPtr=(char *)lpImgData+(BufSize-LineBytes-y*LineBytes);</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>for (x=0;x&lt;bi.biWidth;x++)</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>if(*(lpPtr++)==0) //<SPAN style="FONT-FAMILY: 宋体">是个黑点</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>for (k=0;k&lt;180;k+=2){</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">计算距离</SPAN><SPAN lang=EN-US>i</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
i=(long)fabs((x*cos(k*PI/180.0)+y*sin(k*PI/180.0)));</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">相应的数组元素加</SPAN><SPAN 
lang=EN-US>1</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 
*(lpDistAlpha+i*Alpha+k/2)=*(lpDistAlpha+i*Alpha+k/2)+1;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>TempLine=(MYLINE*)(lpMyLine+i*Alpha+k/2);</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>if(y&gt; (*TempLine).topy){</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">记录该直线最高点的</SPAN><SPAN 
lang=EN-US>x,y</SPAN><SPAN style="FONT-FAMILY: 宋体">坐标</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>(*TempLine).topx=x;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>(*TempLine).topy=y;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>if(y&lt; (*TempLine).boty){</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">记录该直线最低点的</SPAN><SPAN 
lang=EN-US>x,y</SPAN><SPAN style="FONT-FAMILY: 宋体">坐标</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>(*TempLine).botx=x;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>(*TempLine).boty=y;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>}</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>maxd=0;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>for (i=0;i&lt;(long)Dist*Alpha;i++){</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>TempLine=(MYLINE*)(lpMyLine+i);</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>k=*(lpDistAlpha+i);</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>if(k &gt; maxd){</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">找到数组元素中最大的，及相应的直线端点</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>maxd=k;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>MaxdLine.topx=(*TempLine).topx;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>MaxdLine.topy=(*TempLine).topy;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>MaxdLine.botx=(*TempLine).botx;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>MaxdLine.boty=(*TempLine).boty;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>hDc = GetDC(hWnd);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>rhp = CreatePenIndirect(&amp;rlp);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>SelectObject(hDc,rhp);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>MoveToEx(hDc,MaxdLine.botx,MaxdLine.boty,NULL);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">在两端点之间画一条红线用来标识</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>LineTo(hDc,MaxdLine.topx,MaxdLine.topy);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;</SPAN>&nbsp;&nbsp;&nbsp;&nbsp; 
DeleteObject(rhp);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;</SPAN>&nbsp;&nbsp;&nbsp;&nbsp; 
ReleaseDC(hWnd,hDc);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">释放内存及资源</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>GlobalUnlock(hImgData);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
lang=EN-US>GlobalUnlock(hDistAlpha);</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>GlobalFree(hDistAlpha);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp; </SPAN>&nbsp; 
GlobalUnlock(hMyLine);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>GlobalFree(hMyLine);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>return TRUE;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>}</SPAN><SPAN lang=EN-US 
style="FONT-SIZE: 9pt"></SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN style="FONT-FAMILY: 宋体">如果</SPAN><SPAN 
lang=EN-US><SUB> <IMG height=19 src="第7章 边沿检测与提取，轮廓跟踪.files/image047.gif" 
width=13 v:shapes="_x0000_i1055"> </SUB></SPAN><SPAN 
style="FONT-FAMILY: 宋体">是给定的，用上述方法，我们可以找到该方向上最长的直线。</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN style="FONT-FAMILY: 宋体">其实</SPAN><SPAN 
lang=EN-US>Hough</SPAN><SPAN 
style="FONT-FAMILY: 宋体">变换能够查找任意的曲线，只要你给定它的方程。这里，我们就不详述了。</SPAN></P>
<H2><SPAN lang=EN-US>7.3</SPAN> <SPAN lang=EN-US></SPAN><A 
name=_Toc486331900></A><A name=_Toc486332900></A><A name=_Toc486339009></A><A 
name=_Toc454810874></A><A 
name=_Toc454856648><SPAN><SPAN>轮廓提取</SPAN></SPAN></A></H2>
<P style="LINE-HEIGHT: 18pt"><SPAN style="FONT-FAMILY: 宋体">轮廓提取的实例如图</SPAN><SPAN 
lang=EN-US>7.9</SPAN><SPAN style="FONT-FAMILY: 宋体">、图</SPAN><SPAN 
lang=EN-US>7.10</SPAN><SPAN style="FONT-FAMILY: 宋体">所示。</SPAN></P>
<TABLE cellSpacing=0 cellPadding=0 border=0>
  <TBODY>
  <TR>
    <TD class=Normal vAlign=top width=276>
      <P style="LINE-HEIGHT: 18pt; TEXT-ALIGN: center" align=center><B><SPAN 
      lang=EN-US><IMG height=148 src="第7章 边沿检测与提取，轮廓跟踪.files/image049.gif" 
      width=224 v:shapes="_x0000_i1056"> </SPAN></B></P>
      <P style="LINE-HEIGHT: 18pt; TEXT-ALIGN: center" align=center><B><SPAN 
      style="FONT-FAMILY: 宋体">图</SPAN>7.9&nbsp;&nbsp;&nbsp;&nbsp; </B><B><SPAN 
      style="FONT-FAMILY: 宋体">原图</SPAN><SPAN lang=EN-US></SPAN></B></P></TD>
    <TD class=Normal vAlign=top width=276>
      <P class=a style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US><IMG height=148 
      src="第7章 边沿检测与提取，轮廓跟踪.files/image051.gif" width=224 
      v:shapes="_x0000_i1057"> </SPAN></P>
      <P style="LINE-HEIGHT: 18pt; TEXT-ALIGN: center" align=center><B><SPAN 
      style="FONT-FAMILY: 宋体">图</SPAN>7.10&nbsp;&nbsp; </B><B><SPAN 
      style="FONT-FAMILY: 宋体">轮廓提取</SPAN><SPAN 
  lang=EN-US></SPAN></B></P></TD></TR></TBODY></TABLE>
<P style="LINE-HEIGHT: 18pt"><SPAN 
style="FONT-FAMILY: 宋体">轮廓提取的算法非常简单，就是掏空内部点：如果原图中有一点为黑，且它的</SPAN><SPAN 
lang=EN-US>8</SPAN><SPAN style="FONT-FAMILY: 宋体">个相邻点都是黑色时</SPAN><SPAN 
lang=EN-US>(</SPAN><SPAN style="FONT-FAMILY: 宋体">此时该点是内部点</SPAN><SPAN 
lang=EN-US>)</SPAN><SPAN 
style="FONT-FAMILY: 宋体">，则将该点删除。要注意的是，我们处理的虽然是二值图，但实际上是</SPAN><SPAN 
lang=EN-US>256</SPAN><SPAN style="FONT-FAMILY: 宋体">级灰度图，不过只用到了</SPAN><SPAN 
lang=EN-US>0</SPAN><SPAN style="FONT-FAMILY: 宋体">和</SPAN><SPAN 
lang=EN-US>255</SPAN><SPAN style="FONT-FAMILY: 宋体">两种颜色。源程序如下：</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>BOOL Outline(HWND hWnd)</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>{</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
OffBits,BufSize;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp; </SPAN>&nbsp; 
LPBITMAPINFOHEADER&nbsp;&nbsp;&nbsp; lpImgData;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>LPSTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp; lpPtr;</P>
<P 
style="LINE-HEIGHT: 18pt">HLOCAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hTempImgData;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>LPBITMAPINFOHEADER&nbsp;&nbsp;&nbsp; lpTempImgData;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>LPSTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp; lpTempPtr;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>HDC&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
hDc;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>HFILE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hf;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>LONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp; x,y;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
nw,n,ne,w,e,sw,s,se;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体">我们处理的实际上是</SPAN><SPAN lang=EN-US>256</SPAN><SPAN 
style="FONT-FAMILY: 宋体">级灰度图，不过只用到了</SPAN><SPAN lang=EN-US>0</SPAN><SPAN 
style="FONT-FAMILY: 宋体">和</SPAN><SPAN lang=EN-US>255</SPAN><SPAN 
style="FONT-FAMILY: 宋体">两种颜色。</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>if( NumColors!=256){ </SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>MessageBox(hWnd,"Must be a mono 
bitmap with grayscale palette!",</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>"Error 
Message",MB_OK|MB_ICONEXCLAMATION);</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>return FALSE;</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>}</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
lang=EN-US>OffBits=bf.bfOffBits-sizeof(BITMAPFILEHEADER);</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>//BufSize</SPAN><SPAN 
style="FONT-FAMILY: 宋体">为缓冲区大小</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>BufSize=OffBits+bi.biHeight*LineBytes;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">为新图缓冲区分配内存</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>if((hTempImgData=LocalAlloc(LHND,BufSize))==NULL)</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp; </SPAN>{</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp; 
</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(hWnd,"Error 
alloc memory!","Error Message",MB_OK|</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>MB_ICONEXCLAMATION);</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>return FALSE;</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp; </SPAN>}</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp; </SPAN>&nbsp; 
lpImgData=(LPBITMAPINFOHEADER)GlobalLock(hImgData);&nbsp;&nbsp;&nbsp; </P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>lpTempImgData=(LPBITMAPINFOHEADER)LocalLock(hTempImgData);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体">拷贝头信息和位图数据</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>memcpy(lpTempImgData,lpImgData,BufSize);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>for (y=1;y&lt;bi.biHeight-1;y++){ //<SPAN 
style="FONT-FAMILY: 宋体">注意</SPAN><SPAN lang=EN-US>y</SPAN><SPAN 
style="FONT-FAMILY: 宋体">的范围是从</SPAN><SPAN lang=EN-US>1</SPAN><SPAN 
style="FONT-FAMILY: 宋体">到高度</SPAN><SPAN lang=EN-US>-2</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//lpPtr<SPAN style="FONT-FAMILY: 宋体">指向原图数据，</SPAN><SPAN 
lang=EN-US>lpTempPtr</SPAN><SPAN style="FONT-FAMILY: 宋体">指向新图数据</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>lpPtr=(char *)lpImgData+(BufSize-LineBytes-y*LineBytes);</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>lpTempPtr=(char *)lpTempImgData+(BufSize-LineBytes-y*LineBytes);</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>for (x=1;x&lt;bi.biWidth-1;x++){</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>if(*(lpPtr+x)==0){ //<SPAN style="FONT-FAMILY: 宋体">是个黑点</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">查找八个相邻点</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>nw=(unsigned char)*(lpPtr+x+LineBytes-1);</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>n=(unsigned char)*(lpPtr+x+LineBytes);</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>ne=(unsigned char)*(lpPtr+x+LineBytes+1);</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>w=(unsigned char)*(lpPtr+x-1);</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>e=(unsigned char)*(lpPtr+x+1);</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>sw=(unsigned char)*(lpPtr+x-LineBytes-1);</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>s=(unsigned char)*(lpPtr+x-LineBytes);</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>se=(unsigned char)*(lpPtr+x-LineBytes+1);</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>num=nw+n+ne+w+e+sw+s+se;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>if(num==0) //<SPAN style="FONT-FAMILY: 宋体">说明都是黑点</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>*(lpTempPtr+x)=(unsigned char)255; //<SPAN 
style="FONT-FAMILY: 宋体">删除该黑点</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp; </SPAN>&nbsp; 
if(hBitmap!=NULL)</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>&nbsp;&nbsp;&nbsp; DeleteObject(hBitmap);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>hDc=GetDC(hWnd);&nbsp;&nbsp;&nbsp;&nbsp; </P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">创立一个新的位图</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>hBitmap=CreateDIBitmap(hDc,(LPBITMAPINFOHEADER)lpTempImgData,</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>(LONG)CBM_INIT,</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>(LPSTR)lpTempImgData+</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
lang=EN-US>sizeof(BITMAPINFOHEADER)+</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
lang=EN-US>NumColors*sizeof(RGBQUAD),</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
lang=EN-US>(LPBITMAPINFO)lpTempImgData,</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>DIB_RGB_COLORS);</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
lang=EN-US>hf=_lcreat("c:\\outline.bmp",0);</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>_lwrite(hf,(LPSTR)&amp;bf,sizeof(BITMAPFILEHEADER)); </P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>_lwrite(hf,(LPSTR)lpTempImgData,BufSize);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>_lclose(hf);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">释放内存和资源</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;</SPAN>&nbsp;&nbsp;&nbsp;&nbsp; 
ReleaseDC(hWnd,hDc);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>LocalUnlock(hTempImgData);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>LocalFree(hTempImgData);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>GlobalUnlock(hImgData);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>return TRUE;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>}</SPAN></P>
<H2><SPAN lang=EN-US>7.4</SPAN> <SPAN lang=EN-US></SPAN><A 
name=_Toc486331901></A><A name=_Toc486332901></A><A name=_Toc486339010></A><A 
name=_Toc454810875></A><A 
name=_Toc454856649><SPAN><SPAN>种子填充</SPAN></SPAN></A></H2>
<P style="LINE-HEIGHT: 18pt"><SPAN 
style="FONT-FAMILY: 宋体">种子填充算法用来在封闭曲线形成的环中填充某中颜色，在这里我们只填充黑色。</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
style="FONT-FAMILY: 宋体">种子填充其实上是图形学中的算法，其原理是：准备一个堆栈，先将要填充的点</SPAN><SPAN 
lang=EN-US>push</SPAN><SPAN style="FONT-FAMILY: 宋体">进堆栈中；以后，每</SPAN><SPAN 
lang=EN-US>pop</SPAN><SPAN 
style="FONT-FAMILY: 宋体">出一个点，将该点涂成黑色，然后按左上右下的顺序查看它的四个相邻点，若为白</SPAN><SPAN 
lang=EN-US>(</SPAN><SPAN style="FONT-FAMILY: 宋体">表示还没有填充</SPAN><SPAN 
lang=EN-US>)</SPAN><SPAN style="FONT-FAMILY: 宋体">，则将该邻点</SPAN><SPAN 
lang=EN-US>push</SPAN><SPAN 
style="FONT-FAMILY: 宋体">进栈。一直循环，直到堆栈为空。此时，区域内所有的点都被涂成了黑色。</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
style="FONT-FAMILY: 宋体">这里，我们自己定义了一些堆栈的数据结构和操作，实现了堆栈的初始化、</SPAN><SPAN 
lang=EN-US>push</SPAN><SPAN style="FONT-FAMILY: 宋体">、</SPAN><SPAN 
lang=EN-US>pop</SPAN><SPAN style="FONT-FAMILY: 宋体">、判断是否为空、及析构。</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体">堆栈结构</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>typedef struct{</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>&nbsp; HGLOBAL hMem; //<SPAN style="FONT-FAMILY: 宋体">堆栈全局内存句柄</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp; 
</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;POINT *lpMyStack; //<SPAN 
style="FONT-FAMILY: 宋体">指向该句柄的指针</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>&nbsp; LONG&nbsp; ElementsNum; //<SPAN 
style="FONT-FAMILY: 宋体">堆栈的大小</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>&nbsp; LONG&nbsp; ptr; //<SPAN style="FONT-FAMILY: 宋体">指向栈顶的指针</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>&nbsp; }MYSTACK;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体">初始化堆栈的操作，第二个参数指定堆栈的大小</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>BOOL InitStack(HWND hWnd,LONG 
StackLen)</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>{</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>SeedFillStack.ElementsNum=StackLen; //<SPAN 
style="FONT-FAMILY: 宋体">将堆栈的大小赋值</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>if((SeedFillStack.hMem=GlobalAlloc(GHND,SeedFillStack.ElementsNum*</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>sizeof(POINT)))==NULL)</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">内存分配错误，返回</SPAN><SPAN 
lang=EN-US>FALSE;</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp; </SPAN>&nbsp; 
MessageBox(hWnd,"Error alloc memory!","ErrorMessage",MB_OK|</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>MB_ICONEXCLAMATION);</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>return FALSE;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>SeedFillStack.lpMyStack=(POINT *)GlobalLock(SeedFillStack.hMem);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">缓冲区全部清零</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
lang=EN-US>memset(SeedFillStack.lpMyStack,0,SeedFillStack.ElementsNum*</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>sizeof(POINT));</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体">堆顶指针为零</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>SeedFillStack.ptr=0;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">成功，返回</SPAN><SPAN 
lang=EN-US>TRUE</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>return TRUE;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>}</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体">析构函数</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>void DeInitStack()</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>{</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">释放内存，重置堆栈大小及栈顶指针。</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>GlobalUnlock(SeedFillStack.hMem);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>GlobalFree(SeedFillStack.hMem);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>SeedFillStack.ElementsNum=0;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>SeedFillStack.ptr=0;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>}</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>//push</SPAN><SPAN 
style="FONT-FAMILY: 宋体">操作</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>BOOL MyPush(POINT p)</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>{</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>POINT *TempPtr;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>if(SeedFillStack.ptr&gt;=SeedFillStack.ElementsNum) </P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>return FALSE; //<SPAN style="FONT-FAMILY: 宋体">栈已满，返回</SPAN><SPAN 
lang=EN-US>FALSE</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">进栈，栈顶指针加</SPAN><SPAN 
lang=EN-US>1</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>TempPtr=(POINT *)(SeedFillStack.lpMyStack+SeedFillStack.ptr++);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>(*TempPtr).x=p.x;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>(*TempPtr).y=p.y;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>return TRUE;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>}</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>//pop</SPAN><SPAN 
style="FONT-FAMILY: 宋体">操作</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>POINT MyPop()</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>{</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>POINT InvalidP;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>InvalidP.x=-1;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>InvalidP.y=-1;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>if(SeedFillStack.ptr&lt;=0)</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>return InvalidP; //<SPAN style="FONT-FAMILY: 宋体">栈为空，返回无效点</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>SeedFillStack.ptr--; //<SPAN style="FONT-FAMILY: 宋体">栈顶指针减</SPAN><SPAN 
lang=EN-US>1</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">返回栈顶点</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>return *(SeedFillStack.lpMyStack+SeedFillStack.ptr);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>}</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体">判断堆栈是否为空</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>BOOL IsStackEmpty()</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>{</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>return (SeedFillStack.ptr==0)?TRUE:FALSE;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>}</SPAN><SPAN lang=EN-US 
style="FONT-SIZE: 9pt"></SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
style="FONT-FAMILY: 宋体">如果读者对堆栈的概念还不清楚，请参阅有关数据结构方面的书籍，这里就不详述了。</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN style="FONT-FAMILY: 宋体">要注意的是：</SPAN><SPAN 
lang=EN-US>(1)</SPAN><SPAN style="FONT-FAMILY: 宋体">要填充的区域是封闭的；</SPAN><SPAN 
lang=EN-US>(2)</SPAN><SPAN style="FONT-FAMILY: 宋体">我们处理的虽然是二值图，但实际上是</SPAN><SPAN 
lang=EN-US>256</SPAN><SPAN style="FONT-FAMILY: 宋体">级灰度图，不过只用到了</SPAN><SPAN 
lang=EN-US>0</SPAN><SPAN style="FONT-FAMILY: 宋体">和</SPAN><SPAN 
lang=EN-US>255</SPAN><SPAN style="FONT-FAMILY: 宋体">两种颜色；</SPAN><SPAN 
lang=EN-US>(3)</SPAN><SPAN 
style="FONT-FAMILY: 宋体">在菜单中选择种子填充命令时，提示用户用鼠标点取一个要填充区域中的点，处理是在</SPAN><SPAN 
lang=EN-US>WM_LBUTTONDOWN</SPAN><SPAN style="FONT-FAMILY: 宋体">中。</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>MYSTACK SeedFillStack;</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>BOOL SeedFill(HWND 
hWnd)</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>{</SPAN></P>
<P style="LINE-HEIGHT: 18pt">DWORD&nbsp;&nbsp; &nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
OffBits,BufSize;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp; </SPAN>&nbsp; 
LPBITMAPINFOHEADER&nbsp;&nbsp;&nbsp; lpImgData;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>HLOCAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp; hTempImgData;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>LPBITMAPINFOHEADER&nbsp;&nbsp;&nbsp; lpTempImgData;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>LPSTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp; lpTempPtr,lpTempPtr1;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>HDC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hDc;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>HFILE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hf;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>POINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp; CurP,NeighborP;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体">我们处理的实际上是</SPAN><SPAN lang=EN-US>256</SPAN><SPAN 
style="FONT-FAMILY: 宋体">级灰度图，不过只用到了</SPAN><SPAN lang=EN-US>0</SPAN><SPAN 
style="FONT-FAMILY: 宋体">和</SPAN><SPAN lang=EN-US>255</SPAN><SPAN 
style="FONT-FAMILY: 宋体">两种颜色。</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>if( NumColors!=256){</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>MessageBox(hWnd,"Must be a mono 
bitmap with grayscale palette!",</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>"Error 
Message",MB_OK|MB_ICONEXCLAMATION);</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>return FALSE;</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>}</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
lang=EN-US>OffBits=bf.bfOffBits-sizeof(BITMAPFILEHEADER);</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>//BufSize</SPAN><SPAN 
style="FONT-FAMILY: 宋体">为缓冲区大小</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>BufSize=OffBits+bi.biHeight*LineBytes;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体">为新图缓冲区分配内存</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>if((hTempImgData=LocalAlloc(LHND,BufSize))==NULL)</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp; </SPAN>{</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp; 
</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(hWnd,"Error 
alloc memory!","Error Message",MB_OK|</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>MB_ICONEXCLAMATION);</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>return FALSE;</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp; </SPAN>}</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp; </SPAN>&nbsp; 
lpImgData=(LPBITMAPINFOHEADER)GlobalLock(hImgData);&nbsp;&nbsp;&nbsp; </P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>lpTempImgData=(LPBITMAPINFOHEADER)LocalLock(hTempImgData);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体">拷贝头信息和位图数据</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>memcpy(lpTempImgData,lpImgData,BufSize);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>if(!InitStack(hWnd,(LONG)bi.biHeight*bi.biWidth)){&nbsp; //<SPAN 
style="FONT-FAMILY: 宋体">初始化堆栈</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">若失败，释放内存，返回</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>LocalUnlock(hTempImgData);</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>LocalFree(hTempImgData);</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>GlobalUnlock(hImgData);</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>return FALSE;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>lpTempPtr=(char*)lpTempImgData+</P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
lang=EN-US>(BufSize-LineBytes-SeedPoint.y*LineBytes)+SeedPoint.x;</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>if(*lpTempPtr==0){</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">鼠标点到了黑点上，提示用户不能选择边界上的点，返回</SPAN><SPAN 
lang=EN-US>FALSE</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>MessageBox(hWnd,"The point you 
select is a contour point!",</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>"Error 
Message",MB_OK|MB_ICONEXCLAMATION);</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>LocalUnlock(hTempImgData);</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>LocalFree(hTempImgData);</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>GlobalUnlock(hImgData);</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>DeInitStack();</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>return FALSE;</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//push<SPAN style="FONT-FAMILY: 宋体">该点</SPAN><SPAN 
lang=EN-US>(</SPAN><SPAN style="FONT-FAMILY: 宋体">用户用鼠标选择的，处理是在</SPAN><SPAN 
lang=EN-US>WM_LBUTTONDOWN</SPAN><SPAN style="FONT-FAMILY: 宋体">中</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>MyPush(SeedPoint);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>while(!IsStackEmpty()) //<SPAN 
style="FONT-FAMILY: 宋体">堆栈不空则一直处理</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>CurP=MyPop(); //pop<SPAN style="FONT-FAMILY: 宋体">栈顶的点</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>lpTempPtr=(char*)lpTempImgData+</P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
lang=EN-US>(BufSize-LineBytes-CurP.y*LineBytes)+CurP.x;</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">将该点涂黑</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>*lpTempPtr=(unsigned char)0;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">左邻点</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>if(CurP.x&gt;0) //<SPAN style="FONT-FAMILY: 宋体">注意判断边界</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>NeighborP.x=CurP.x-1;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>NeighborP.y=CurP.y;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>lpTempPtr1=lpTempPtr-1;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>if(*lpTempPtr1!=0) //<SPAN 
style="FONT-FAMILY: 宋体">如果为白，表示还没有填，进栈</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>MyPush(NeighborP);</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体">上邻点</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>if(CurP.y&gt;0) //<SPAN style="FONT-FAMILY: 宋体">注意判断边界</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>NeighborP.x=CurP.x;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>NeighborP.y=CurP.y-1;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>lpTempPtr1=lpTempPtr+LineBytes;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>if(*lpTempPtr1!=0) //<SPAN 
style="FONT-FAMILY: 宋体">如果为白，表示还没有填，进栈</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>MyPush(NeighborP);</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体">右邻点</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>if(CurP.x&lt;bi.biWidth-1) //<SPAN 
style="FONT-FAMILY: 宋体">注意判断边界</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>NeighborP.x=CurP.x+1;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>NeighborP.y=CurP.y;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>lpTempPtr1=lpTempPtr+1;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>if(*lpTempPtr1!=0) //<SPAN 
style="FONT-FAMILY: 宋体">如果为白，表示还没有填，进栈</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>MyPush(NeighborP);</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">下邻点</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>if(CurP.y&lt;bi.biHeight-1) //<SPAN 
style="FONT-FAMILY: 宋体">注意判断边界</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>NeighborP.x=CurP.x;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>NeighborP.y=CurP.y+1;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>lpTempPtr1=lpTempPtr-LineBytes;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>if(*lpTempPtr1!=0) //<SPAN 
style="FONT-FAMILY: 宋体">如果为白，表示还没有填，进栈</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>MyPush(NeighborP);</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">析构堆栈，释放内存</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>DeInitStack();</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>if(hBitmap!=NULL)</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>&nbsp;&nbsp;&nbsp; DeleteObject(hBitmap);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>hDc=GetDC(hWnd);&nbsp;&nbsp;&nbsp;&nbsp; </P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">创建新的位图</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>hBitmap=CreateDIBitmap(hDc,(LPBITMAPINFOHEADER)lpTempImgData,</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>(LONG)CBM_INIT,</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>(LPSTR)lpTempImgData+</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
lang=EN-US>sizeof(BITMAPINFOHEADER)+</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
lang=EN-US>NumColors*sizeof(RGBQUAD),</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
lang=EN-US>(LPBITMAPINFO)lpTempImgData,</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>DIB_RGB_COLORS);</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>hf=_lcreat("c:\\seed.bmp",0);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>_lwrite(hf,(LPSTR)&amp;bf,sizeof(BITMAPFILEHEADER)); </P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>_lwrite(hf,(LPSTR)lpTempImgData,BufSize);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>_lclose(hf);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">释放内存和资源</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;</SPAN>&nbsp;&nbsp;&nbsp;&nbsp; 
ReleaseDC(hWnd,hDc);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>LocalUnlock(hTempImgData);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>LocalFree(hTempImgData);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>GlobalUnlock(hImgData);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>return TRUE;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>}</SPAN></P>
<H2><SPAN lang=EN-US>7.5</SPAN> <SPAN lang=EN-US></SPAN><A 
name=_Toc486331902></A><A name=_Toc486332902></A><A name=_Toc486339011></A><A 
name=_Toc454810876></A><A 
name=_Toc454856650><SPAN><SPAN>轮廓跟踪</SPAN></SPAN></A></H2>
<P style="LINE-HEIGHT: 18pt"><SPAN 
style="FONT-FAMILY: 宋体">轮廓跟踪，顾名思义就是通过顺序找出边缘点来跟踪出边界。图</SPAN><SPAN 
lang=EN-US>7.9</SPAN><SPAN style="FONT-FAMILY: 宋体">经轮廓跟踪后得到的结果如图</SPAN><SPAN 
lang=EN-US>7.11</SPAN><SPAN style="FONT-FAMILY: 宋体">所示。</SPAN></P>
<P style="LINE-HEIGHT: 18pt; TEXT-ALIGN: center" align=center><SPAN 
lang=EN-US><IMG height=148 src="第7章 边沿检测与提取，轮廓跟踪.files/image053.gif" width=224 
v:shapes="_x0000_i1058"> </SPAN></P>
<P style="LINE-HEIGHT: 18pt; TEXT-ALIGN: center" align=center><B><SPAN 
style="FONT-FAMILY: 宋体">图</SPAN>7.11&nbsp;&nbsp;&nbsp; </B><B><SPAN 
style="FONT-FAMILY: 宋体">图</SPAN><SPAN lang=EN-US>7.9</SPAN></B><B><SPAN 
style="FONT-FAMILY: 宋体">轮廓跟踪后的结果</SPAN><SPAN lang=EN-US></SPAN></B></P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
style="FONT-FAMILY: 宋体">一个简单二值图象闭合边界的轮廓跟踪算法很简单：首先按从上到下，从左到右的顺序搜索，找到的第一个黑点一定是最左上方的边界点，记为</SPAN><SPAN 
lang=EN-US>A</SPAN><SPAN 
style="FONT-FAMILY: 宋体">。它的右，右下，下，左下四个邻点中至少有一个是边界点，记为</SPAN><SPAN 
lang=EN-US>B</SPAN><SPAN style="FONT-FAMILY: 宋体">。从开始</SPAN><SPAN 
lang=EN-US>B</SPAN><SPAN 
style="FONT-FAMILY: 宋体">找起，按右，右下，下，左下，左，左上，上，右上的顺序找相邻点中的边界点</SPAN><SPAN 
lang=EN-US>C</SPAN><SPAN style="FONT-FAMILY: 宋体">。如果</SPAN><SPAN 
lang=EN-US>C</SPAN><SPAN style="FONT-FAMILY: 宋体">就是</SPAN><SPAN 
lang=EN-US>A</SPAN><SPAN 
style="FONT-FAMILY: 宋体">点，则表明已经转了一圈，程序结束；否则从</SPAN><SPAN 
lang=EN-US>C</SPAN><SPAN style="FONT-FAMILY: 宋体">点继续找，直到找到</SPAN><SPAN 
lang=EN-US>A</SPAN><SPAN 
style="FONT-FAMILY: 宋体">为止。判断是不是边界点很容易：如果它的上下左右四个邻居都是黑点则不是边界点，否则是边界点。源程序如下，其中函数</SPAN><SPAN 
lang=EN-US>IsContourP</SPAN><SPAN 
style="FONT-FAMILY: 宋体">用来判断某点是不是边界点。</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>BOOL Contour(HWND hWnd)</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>{</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>DWORD&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OffBits<SPAN 
style="FONT-FAMILY: 宋体">，</SPAN><SPAN lang=EN-US>BufSize;</SPAN></P>
<P style="LINE-HEIGHT: 18pt">LPBITMAPINFOHEADER&nbsp;&nbsp;&nbsp; lpImgData;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>LPSTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp; lpPtr;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>HLOCAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp; hTempImgData;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>LPBITMAPINFOHEADER&nbsp;&nbsp;&nbsp; lpTempImgData;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>LPSTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp; lpTempPtr;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>HDC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hDc;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>HFILE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hf;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>LONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp; x,y;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>POINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp; StartP,CurP;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; found;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</P>
<P style="LINE-HEIGHT: 18pt">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
direct[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体">我们处理的实际上是</SPAN><SPAN lang=EN-US>256</SPAN><SPAN 
style="FONT-FAMILY: 宋体">级灰度图，不过只用到了</SPAN><SPAN lang=EN-US>0</SPAN><SPAN 
style="FONT-FAMILY: 宋体">和</SPAN><SPAN lang=EN-US>255</SPAN><SPAN 
style="FONT-FAMILY: 宋体">两种颜色。</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>if( NumColors!=256){</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>MessageBox(hWnd,"Must be a mono 
bitmap with grayscale palette!",</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>"Error 
Message",MB_OK|MB_ICONEXCLAMATION);</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>return FALSE;</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>}</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体">到位图数据的偏移值</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>OffBits=bf.bfOffBits-sizeof(BITMAPFILEHEADER);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">缓冲区大小</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
lang=EN-US>BufSize=OffBits+bi.biHeight*LineBytes;</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体">为新图缓冲区分配内存</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>if((hTempImgData=LocalAlloc(LHND,BufSize))==NULL)</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp; </SPAN>&nbsp; {</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>MessageBox(hWnd,"Error alloc memory!","Error Message",</P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
lang=EN-US>MB_OK|MB_ICONEXCLAMATION);</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>return FALSE;</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>}</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp; </SPAN>&nbsp;&nbsp;&nbsp; 
lpImgData=(LPBITMAPINFOHEADER)GlobalLock(hImgData);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>lpTempImgData=(LPBITMAPINFOHEADER)LocalLock(hTempImgData);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">新图缓冲区初始化为</SPAN><SPAN 
lang=EN-US>255</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>memset(lpTempImgData,(BYTE)255,BufSize);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">拷贝头信息</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>memcpy(lpTempImgData,lpImgData,OffBits);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">找到标志置为假</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>found=FALSE;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>for (y=0;y&lt;bi.biHeight &amp;&amp; !found; y++){</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>lpPtr=(char *)lpImgData+(BufSize-LineBytes-y*LineBytes);</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>for (x=0;x&lt;bi.biWidth &amp;&amp; !found; x++)</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>if (*(lpPtr++) ==0) found=TRUE; </P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体">找到了最左上的黑点，一定是个边界点</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>if(found){ //<SPAN style="FONT-FAMILY: 宋体">如果找到了，才做处理</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体">从循环退出时，</SPAN><SPAN lang=EN-US>x</SPAN><SPAN 
style="FONT-FAMILY: 宋体">，</SPAN><SPAN lang=EN-US>y</SPAN><SPAN 
style="FONT-FAMILY: 宋体">坐标都做了加</SPAN><SPAN lang=EN-US>1</SPAN><SPAN 
style="FONT-FAMILY: 宋体">的操作。在这里把它们减</SPAN><SPAN lang=EN-US>1</SPAN><SPAN 
style="FONT-FAMILY: 宋体">，得到</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体">起始点坐标</SPAN><SPAN lang=EN-US>StartP</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>StartP.x=x-1;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>StartP.y=y-1;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>lpTempPtr=(char*)lpTempImgData+</P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
lang=EN-US>(BufSize-LineBytes-StartP.y*LineBytes)+StartP.x;</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>*lpTempPtr=(unsigned char)0; //<SPAN 
style="FONT-FAMILY: 宋体">起始点涂黑</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">右邻点</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp; 
</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CurP.x=StartP.x+1;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>CurP.y=StartP.y;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>lpPtr=(char *)lpImgData+(BufSize-LineBytes-CurP.y*LineBytes)+CurP.x;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>if(*lpPtr!=0){ //<SPAN style="FONT-FAMILY: 宋体">若右邻点为白，则找右下邻点</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
CurP.x=StartP.x+1;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>CurP.y=StartP.y+1;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>lpPtr=(char*)lpImgData+</P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
lang=EN-US>(BufSize-LineBytes-CurP.y*LineBytes)+CurP.x;</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>if(*lpPtr!=0){ //<SPAN style="FONT-FAMILY: 宋体">若仍为白，则找下邻点</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
CurP.x=StartP.x;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>CurP.y=StartP.y+1;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>else{ //<SPAN style="FONT-FAMILY: 宋体">若仍为白，则找左下邻点</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
CurP.x=StartP.x-1;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>CurP.y=StartP.y+1;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>while (! ( (CurP.x==StartP.x) &amp;&amp;(CurP.y==StartP.y))){ //<SPAN 
style="FONT-FAMILY: 宋体">知道找到起始点，</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体">循环才结束</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>lpTempPtr=(char*)lpTempImgData+</P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
lang=EN-US>(BufSize-LineBytes-CurP.y*LineBytes)+CurP.x;</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>*lpTempPtr=(unsigned char)0;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>for(i=0;i&lt;8;i++){ </P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体">按右，右上，上，左上，左，左下，下，右下的顺序找相邻点</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>//direct[i]</SPAN><SPAN 
style="FONT-FAMILY: 宋体">中存放的是该方向</SPAN><SPAN lang=EN-US>x,y</SPAN><SPAN 
style="FONT-FAMILY: 宋体">的偏移值</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>x=CurP.x+direct[i][0];</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>y=CurP.y+direct[i][1];</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//lpPtr<SPAN style="FONT-FAMILY: 宋体">指向原图数据，</SPAN><SPAN 
lang=EN-US>lpTempPtr</SPAN><SPAN style="FONT-FAMILY: 宋体">指向新图数据</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>lpTempPtr=(char*)lpTempImgData+</P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
lang=EN-US>(BufSize-LineBytes-y*LineBytes)+x;</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>lpPtr=(char *)lpImgData+(BufSize-LineBytes-y*LineBytes)+x;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>if(((*lpPtr==0)&amp;&amp;(*lpTempPtr!=0))||</P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
lang=EN-US>((x==StartP.x)&amp;&amp;(y==StartP.y)))</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">原图中为黑点，且新图中为白点</SPAN><SPAN 
lang=EN-US>(</SPAN><SPAN style="FONT-FAMILY: 宋体">表示还没搜索过</SPAN><SPAN 
lang=EN-US>)</SPAN><SPAN style="FONT-FAMILY: 宋体">时才处理</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">另一种可能是找到了起始点</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(IsContourP(x,y,lpPtr)){ //<SPAN 
style="FONT-FAMILY: 宋体">若是个边界点</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //<SPAN 
style="FONT-FAMILY: 宋体">记住当前点的位置</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>CurP.x=x;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>CurP.y=y;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>break;</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}</P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp; 
</SPAN>&nbsp;&nbsp;if(hBitmap!=NULL)</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>&nbsp;&nbsp;&nbsp; DeleteObject(hBitmap);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>hDc=GetDC(hWnd);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">创立一个新的位图</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>hBitmap=CreateDIBitmap(hDc,(LPBITMAPINFOHEADER)lpTempImgData,</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>(LONG)CBM_INIT,</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>(LPSTR)lpTempImgData+</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
lang=EN-US>sizeof(BITMAPINFOHEADER)+</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN 
lang=EN-US>NumColors*sizeof(RGBQUAD),</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
(LPBITMAPINFO)lpTempImgData,</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>DIB_RGB_COLORS);</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>hf=_lcreat("c:\\contour.bmp",0);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>_lwrite(hf,(LPSTR)&amp;bf,sizeof(BITMAPFILEHEADER)); </P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>_lwrite(hf,(LPSTR)lpTempImgData,BufSize);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>_lclose(hf);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="FONT-FAMILY: 宋体">释放内存和资源</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;</SPAN>&nbsp;&nbsp;&nbsp;&nbsp; 
ReleaseDC(hWnd,hDc);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>LocalUnlock(hTempImgData);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>LocalFree(hTempImgData);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>GlobalUnlock(hImgData);</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>return TRUE;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>}</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体">判断某点是不是边界点，参数</SPAN><SPAN lang=EN-US>x,y </SPAN><SPAN 
style="FONT-FAMILY: 宋体">为该点坐标，</SPAN><SPAN lang=EN-US>lpPtr</SPAN><SPAN 
style="FONT-FAMILY: 宋体">为指向原数据的指针</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>BOOL IsContourP(LONG x,LONG y, 
char *lpPtr)</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>{</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>int&nbsp;&nbsp;&nbsp; num,n,w,e,s;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>n=(unsigned char)*(lpPtr+LineBytes); //<SPAN 
style="FONT-FAMILY: 宋体">上邻点</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>w=(unsigned char)*(lpPtr-1); //<SPAN 
style="FONT-FAMILY: 宋体">左邻点</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>e=(unsigned char)*(lpPtr+1); //<SPAN 
style="FONT-FAMILY: 宋体">右邻点</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>s=(unsigned char)*(lpPtr-LineBytes); //<SPAN 
style="FONT-FAMILY: 宋体">下邻点</SPAN></P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>num=n+w+e+s;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>if(num==0) //<SPAN style="FONT-FAMILY: 宋体">全是黑点，说明是个内部点而不是边界点</SPAN></P>
<P 
style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>return FALSE;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>return TRUE;</P>
<P style="LINE-HEIGHT: 18pt"><SPAN lang=EN-US>}</SPAN></P></DIV>
<DIV 
style="DISPLAY: block; FONT-SIZE: 10px; FONT-FAMILY: Verdana, Geneva, Arial">The 
University of Southern California does not screen or control the content on this 
website and thus does not guarantee the accuracy, integrity, or quality of such 
content. All content on this website is provided by and is the sole 
responsibility of the person from which such content originated, and such 
content does not necessarily reflect the opinions of the University 
administration or the Board of Trustees </DIV></BODY></HTML>
